= ContactHub - Developer Guide
:toc:
:toc-title:
:toc-placement: preamble
:sectnums:
:imagesDir: images
:stylesDir: stylesheets
ifdef::env-github[]
:tip-caption: :bulb:
:note-caption: :information_source:
endif::[]
ifdef::env-github,env-browser[:outfilesuffix: .adoc]
:repoURL: https://github.com/CS2103AUG2017-T11-B2/main/tree/master

By: `CS2103T T11-B2`      Since: `Sep 2017`      Licence: `MIT`

== Setting up

=== Prerequisites

. *JDK `1.8.0_60`* or later
+
[NOTE]
Having any Java 8 version is not enough. +
This app will not work with earlier versions of Java 8.
+

. *IntelliJ* IDE
+
[NOTE]
IntelliJ by default has Gradle and JavaFx plugins installed. +
Do not disable them. If you have disabled them, go to `File` > `Settings` > `Plugins` to re-enable them.


=== Setting up the project in your computer

. Fork this repo, and clone the fork to your computer
. Open IntelliJ (if you are not in the welcome screen, click `File` > `Close Project` to close the existing project dialog first)
. Set up the correct JDK version for Gradle
.. Click `Configure` > `Project Defaults` > `Project Structure`
.. Click `New...` and find the directory of the JDK
. Click `Import Project`
. Locate the `build.gradle` file and select it. Click `OK`
. Click `Open as Project`
. Click `OK` to accept the default settings
. Open a console and run the command `gradlew processResources` (Mac/Linux: `./gradlew processResources`). It should finish with the `BUILD SUCCESSFUL` message. +
This will generate all resources required by the application and tests.

=== Verifying the setup

. Run the `seedu.address.MainApp` and try a few commands
. link:#testing[Run the tests] to ensure they all pass.

=== Configurations to do before writing code

==== Configuring the coding style

This project follows https://github.com/oss-generic/process/blob/master/docs/CodingStandards.md[oss-generic coding standards]. IntelliJ's default style is mostly compliant with ours but it uses a different import order from ours. To rectify,

. Go to `File` > `Settings...` (Windows/Linux), or `IntelliJ IDEA` > `Preferences...` (macOS)
. Select `Editor` > `Code Style` > `Java`
. Click on the `Imports` tab to set the order

* For `Class count to use import with '\*'` and `Names count to use static import with '*'`: Set to `999` to prevent IntelliJ from contracting the import statements
* For `Import Layout`: The order is `import static all other imports`, `import java.\*`, `import javax.*`, `import org.\*`, `import com.*`, `import all other imports`. Add a `<blank line>` between each `import`

Optionally, you can follow the <<UsingCheckstyle#, UsingCheckstyle.adoc>> document to configure Intellij to check style-compliance as you write code.

==== Updating documentation to match your fork

After forking the repo, links in the documentation will still point to the `CS2103AUG2017-T11-B2/main` repo. If you plan to develop this as a separate product (i.e. instead of contributing to the `CS2103AUG2017-T11-B2/main`) , you should replace the URL in the variable `repoURL` in `DeveloperGuide.adoc` and `UserGuide.adoc` with the URL of your fork.

==== Setting up CI

Set up Travis to perform Continuous Integration (CI) for your fork. See <<UsingTravis#, UsingTravis.adoc>> to learn how to set it up.

Optionally, you can set up AppVeyor as a second CI (see <<UsingAppVeyor#, UsingAppVeyor.adoc>>).

[NOTE]
Having both Travis and AppVeyor ensures your App works on both Unix-based platforms and Windows-based platforms (Travis is Unix-based and AppVeyor is Windows-based)

==== Getting started with coding

When you are ready to start coding,

1. Get some sense of the overall design by reading the link:#architecture[Architecture] section.
2. Take a look at the section link:#suggested-programming-tasks-to-get-started[Suggested Programming Tasks to Get Started].

== Design

=== Architecture

image::Architecture.png[width="600"]
_Figure 2.1.1 : Architecture Diagram_

*_Figure 2.1.1_* explains the high-level design of the App. Given below is a quick overview of the Main and Commons component.

[TIP]
The `.pptx` files used to create diagrams in this document can be found in the link:{repoURL}/docs/diagrams/[diagrams] folder. To update a diagram, modify the diagram in the pptx file, select the objects of the diagram, and choose `Save as picture`.

`Main` has only one class called link:{repoURL}/src/main/java/seedu/address/MainApp.java[`MainApp`]. It is responsible for,

* At app launch: Initializes the components in the correct sequence, and connects them up with each other.
* At shut down: Shuts down the components and invokes cleanup method where necessary.

link:#common-classes[*`Commons`*] represents a collection of classes used by multiple other components. Classes used by multiple components are in the `seedu.addressbook.commons` package.
Two of those classes play important roles at the architecture level:

* `EventsCenter` : This class (written using https://github.com/google/guava/wiki/EventBusExplained[Google's Event Bus library]) is used by components to communicate with other components using events (i.e. a form of _Event Driven_ design)
* `LogsCenter` : Used by many classes to write log messages to the App's log file.

The rest of the App consists of four components.

* link:#ui-component[*`UI`*] : The UI of the App.
* link:#logic-component[*`Logic`*] : The command executor.
* link:#model-component[*`Model`*] : Holds the data of the App in-memory.
* link:#storage-component[*`Storage`*] : Reads data from, and writes data to, the hard disk.

Each of the four components

* Defines its _API_ in an `interface` with the same name as the Component.
* Exposes its functionality using a `{Component Name}Manager` class.

For example, the `Logic` component (see the class diagram given below) defines it's API in the `Logic.java` interface and exposes its functionality using the `LogicManager.java` class.

image::LogicClassDiagram.png[width="800"]
_Figure 2.1.2 : Class Diagram of the Logic Component_

[discrete]
==== Events-Driven nature of the design

The _Sequence Diagram_ below shows how the components interact for the scenario where the user issues the command `delete 1`.

image::SDforDeletePerson.png[width="800"]
_Figure 2.1.3a : Component interactions for `delete 1` command (part 1)_

[NOTE]
Note how the `Model` simply raises a `AddressBookChangedEvent` when the Address Book data are changed, instead of asking the `Storage` to save the updates to the hard disk.

The diagram below shows how the `EventsCenter` reacts to that event, which eventually results in the updates being saved to the hard disk and the status bar of the UI being updated to reflect the 'Last Updated' time.

image::SDforDeletePersonEventHandling.png[width="800"]
_Figure 2.1.3b : Component interactions for `delete 1` command (part 2)_

[NOTE]
Note how the event is propagated through the `EventsCenter` to the `Storage` and `UI` without `Model` having to be coupled to either of them. This is an example of how this Event Driven approach helps us reduce direct coupling between components.

The sections below give more details of each component.

=== UI component

image::UiClassDiagram.png[width="800"]
_Figure 2.2.1 : Structure of the UI Component_

*API* : link:{repoURL}/src/main/java/seedu/address/ui/Ui.java[`Ui.java`]

The UI consists of a `MainWindow` that is made up of parts e.g.`CommandBox`, `ResultDisplay`, `PersonListPanel`, `StatusBarFooter`, `BrowserPanel` etc. All these, including the `MainWindow`, inherit from the abstract `UiPart` class.

The `UI` component uses JavaFx UI framework. The layout of these UI parts are defined in matching `.fxml` files that are in the `src/main/resources/view` folder. For example, the layout of the link:{repoURL}/src/main/java/seedu/address/ui/MainWindow.java[`MainWindow`] is specified in link:{repoURL}/src/main/resources/view/MainWindow.fxml[`MainWindow.fxml`]

The `UI` component,

* Executes user commands using the `Logic` component.
* Binds itself to some data in the `Model` so that the UI can auto-update when data in the `Model` change.
* Responds to events raised from various parts of the App and updates the UI accordingly.

=== Logic component

image::LogicClassDiagram.png[width="800"]
_Figure 2.3.1 : Structure of the Logic Component_

image::LogicCommandClassDiagram.png[width="800"]
_Figure 2.3.2 : Structure of Commands in the Logic Component. This diagram shows finer details concerning `XYZCommand` and `Command` in Figure 2.3.1_

*API* :
link:{repoURL}/src/main/java/seedu/address/logic/Logic.java[`Logic.java`]

`Logic` uses the `AddressBookParser` class to parse the user command. This results in a `Command` object which is executed by the `LogicManager`.
The command execution can affect the `Model` (e.g. adding a person) and/or raise events.

The result of the command execution is encapsulated as a `CommandResult` object which is passed back to the `Ui`.
Given below is the Sequence Diagram for interactions within the `Logic` component for the `execute("delete 1")` API call.

image::DeletePersonSdForLogic.png[width="800"]
_Figure 2.3.3 : Interactions Inside the Logic Component for the `delete 1` Command_

=== Model component

image::ModelClassDiagram.png[width="800"]
_Figure 2.4.1 : Structure of the Model Component_

*API* : link:{repoURL}/src/main/java/seedu/address/model/Model.java[`Model.java`]

The `Model`,

* stores a `UserPref` object that represents the user's preferences.
* stores the Address Book data.
* exposes an unmodifiable `ObservableList<ReadOnlyPerson>` that can be 'observed' e.g. the UI can be bound to this list so that the UI automatically updates when the data in the list change.
* does not depend on any of the other three components.

=== Storage component

image::StorageClassDiagram.png[width="800"]
_Figure 2.5.1 : Structure of the Storage Component_

*API* : link:{repoURL}/src/main/java/seedu/address/storage/Storage.java[`Storage.java`]

The `Storage` component,

* can save `UserPref` objects in json format and read it back.
* can save the Address Book data in xml format and read it back.

== Implementation

This section describes some noteworthy details on how certain features are implemented.

// tag::undoredo[]
=== Undo/Redo mechanism

The undo/redo mechanism is facilitated by an `UndoRedoStack`, which resides inside `LogicManager`. It supports undoing and redoing of commands that modifies the state of the address book (e.g. `add`, `edit`). Such commands will inherit from `UndoableCommand`.

`UndoRedoStack` only deals with `UndoableCommands`. Commands that cannot be undone will inherit from `Command` instead. The following diagram shows the inheritance diagram for commands:

image::LogicCommandClassDiagram.png[width="800"]

As you can see from the diagram, `UndoableCommand` adds an extra layer between the abstract `Command` class and concrete commands that can be undone, such as the `DeleteCommand`. Note that extra tasks need to be done when executing a command in an _undoable_ way, such as saving the state of the address book before execution. `UndoableCommand` contains the high-level algorithm for those extra tasks while the child classes implements the details of how to execute the specific command. Note that this technique of putting the high-level algorithm in the parent class and lower-level steps of the algorithm in child classes is also known as the https://www.tutorialspoint.com/design_pattern/template_pattern.htm[template pattern].

Commands that are not undoable are implemented this way:
[source,java]
----
public class ListCommand extends Command {
    @Override
    public CommandResult execute() {
        // ... list logic ...
    }
}
----

With the extra layer, the commands that are undoable are implemented this way:
[source,java]
----
public abstract class UndoableCommand extends Command {
    @Override
    public CommandResult execute() {
        // ... undo logic ...

        executeUndoableCommand();
    }
}

public class DeleteCommand extends UndoableCommand {
    @Override
    public CommandResult executeUndoableCommand() {
        // ... delete logic ...
    }
}
----

Suppose that the user has just launched the application. The `UndoRedoStack` will be empty at the beginning.

The user executes a new `UndoableCommand`, `delete 5`, to delete the 5th person in the address book. The current state of the address book is saved before the `delete 5` command executes. The `delete 5` command will then be pushed onto the `undoStack` (the current state is saved together with the command).

image::UndoRedoStartingStackDiagram.png[width="800"]

As the user continues to use the program, more commands are added into the `undoStack`. For example, the user may execute `add n/David ...` to add a new person.

image::UndoRedoNewCommand1StackDiagram.png[width="800"]

[NOTE]
If a command fails its execution, it will not be pushed to the `UndoRedoStack` at all.

The user now decides that adding the person was a mistake, and decides to undo that action using `undo`.

We will pop the most recent command out of the `undoStack` and push it back to the `redoStack`. We will restore the address book to the state before the `add` command executed.

image::UndoRedoExecuteUndoStackDiagram.png[width="800"]

[NOTE]
If the `undoStack` is empty, then there are no other commands left to be undone, and an `Exception` will be thrown when popping the `undoStack`.

The following sequence diagram shows how the undo operation works:

image::UndoRedoSequenceDiagram.png[width="800"]

The redo does the exact opposite (pops from `redoStack`, push to `undoStack`, and restores the address book to the state after the command is executed).

[NOTE]
If the `redoStack` is empty, then there are no other commands left to be redone, and an `Exception` will be thrown when popping the `redoStack`.

The user now decides to execute a new command, `clear`. As before, `clear` will be pushed into the `undoStack`. This time the `redoStack` is no longer empty. It will be purged as it no longer make sense to redo the `add n/David` command (this is the behavior that most modern desktop applications follow).

image::UndoRedoNewCommand2StackDiagram.png[width="800"]

Commands that are not undoable are not added into the `undoStack`. For example, `list`, which inherits from `Command` rather than `UndoableCommand`, will not be added after execution:

image::UndoRedoNewCommand3StackDiagram.png[width="800"]

The following activity diagram summarize what happens inside the `UndoRedoStack` when a user executes a new command:

image::UndoRedoActivityDiagram.png[width="200"]

==== Design Considerations

**Aspect:** Implementation of `UndoableCommand` +
**Alternative 1 (current choice):** Add a new abstract method `executeUndoableCommand()` +
**Pros:** We will not lose any undone/redone functionality as it is now part of the default behaviour. Classes that deal with `Command` do not have to know that `executeUndoableCommand()` exist. +
**Cons:** Hard for new developers to understand the template pattern. +
**Alternative 2:** Just override `execute()` +
**Pros:** Does not involve the template pattern, easier for new developers to understand. +
**Cons:** Classes that inherit from `UndoableCommand` must remember to call `super.execute()`, or lose the ability to undo/redo.

---

**Aspect:** How undo & redo executes +
**Alternative 1 (current choice):** Saves the entire address book. +
**Pros:** Easy to implement. +
**Cons:** May have performance issues in terms of memory usage. +
**Alternative 2:** Individual command knows how to undo/redo by itself. +
**Pros:** Will use less memory (e.g. for `delete`, just save the person being deleted). +
**Cons:** We must ensure that the implementation of each individual command are correct.

---

**Aspect:** Type of commands that can be undone/redone +
**Alternative 1 (current choice):** Only include commands that modifies the address book (`add`, `clear`, `edit`). +
**Pros:** We only revert changes that are hard to change back (the view can easily be re-modified as no data are lost). +
**Cons:** User might think that undo also applies when the list is modified (undoing filtering for example), only to realize that it does not do that, after executing `undo`. +
**Alternative 2:** Include all commands. +
**Pros:** Might be more intuitive for the user. +
**Cons:** User have no way of skipping such commands if he or she just want to reset the state of the address book and not the view. +
**Additional Info:** See our discussion  https://github.com/se-edu/addressbook-level4/issues/390#issuecomment-298936672[here].

---

**Aspect:** Data structure to support the undo/redo commands +
**Alternative 1 (current choice):** Use separate stack for undo and redo +
**Pros:** Easy to understand for new Computer Science student undergraduates to understand, who are likely to be the new incoming developers of our project. +
**Cons:** Logic is duplicated twice. For example, when a new command is executed, we must remember to update both `HistoryManager` and `UndoRedoStack`. +
**Alternative 2:** Use `HistoryManager` for undo/redo +
**Pros:** We do not need to maintain a separate stack, and just reuse what is already in the codebase. +
**Cons:** Requires dealing with commands that have already been undone: We must remember to skip these commands. Violates Single Responsibility Principle and Separation of Concerns as `HistoryManager` now needs to do two different things. +
// end::undoredo[]

// tag::listmodules[]
=== ListModules mechanism

The ListModules mechanism is implemented using the `ListModuleCommand`, which resides inside `Logic`. It supports listing of all the modules in ContactHub associated with.

When the user requests for the list of all the modules, a list of modules will be created and shown in an alphabetical manner in the result display.

`ListModuleCommand` inherits from Command and is implemented this way.
[source,java]
----
public class ListModuleCommand extends Command {
    @Override
    public CommandResult execute() {
        // ... ListModules logic ...
        }
}
----

The user executes `ListModuleCommand`, the result display will list out all the modules in ContactHub.

image::ListModuleCommand.png[width="300"]

==== Design Considerations

**Aspect:** Implementation of `ListModuleCommand` +
**Alternative 1 (current choice):** `ListModuleCommand` inherits from `Command`. +
**Pros:** After listing, the contact list remains as per normal when command is keyed in. +
**Cons:** The contact list cannot be sorted by modules after command is keyed in.

---

**Aspect:** How listModules executes +
**Alternative 1 (current choice):** Uses the Java Collections.sort() method to get the list of all modules. +
**Pros:** Easy to implement. +
**Cons:** This method is difficult to debug. +
**Alternative 2:** Creates a new listModules algorithm. +
**Pros:** This method is easier to debug. +
**Cons:** We must ensure that the algorithm's logic is right and efficient.
// end::listmodules[]

// tag::findmodule[]
=== FindModule mechanism

The FindModule mechanism is implemented using the `FindModuleCommand`, which resides inside `Logic`. It supports listing of all the contacts in ContacHub associated with.

When the user requests for contacts associated to a module(s), the list of contacts will be created and shown.

`FindModuleCommand` inherits from Command and is implemented this way.
[source,java]
----
public class FindModuleCommand extends Command {
    @Override
    public CommandResult execute() {
        // ... findModule logic ...
        }
}
----

Suppose that the user has just launched ContactHub. The contact list will be arranged based on the add order at the beginning.

image::ListCommand.png[width="300"]

The user executes `FindModuleCommand`, the list will now show the contacts associated to the module(s) keyed in.

image::FindModuleCommand.png[width="300"]

The user can continue to add more module(s) for the FindModuleCommand, and if any contacts contains any of the module(s) keyed in, they will show up

[NOTE]
Upon exiting ContactHub, the contact list will not be filtered for according to the last module(s) keyed in in the next launch.

==== Design Considerations

**Aspect:** Implementation of `FindModuleCommand` +
**Alternative 1 (current choice):** `FindModuleCommand` inherits from `Command`. +
**Pros:** After filtering, the contact list remains will only show contacts associated to the module(s) keyed in. +
**Cons:** The contact list cannot be saved after filtering. +
**Alternative 2:** Implement undo/redo for `FilterCommand`. +
**Pros:** The user can switch between the filtered contact list and the original contact list.  +
**Cons:** `FindModuleCommand` must be extended from `UndoableCommand` and must remember to call `super.execute()`, or lose the ability to undo/redo.

---

**Aspect:** How findModule executes +
**Alternative 1 (current choice):** Uses the Java Collections.stream() method to filter the contact list. +
**Pros:** Easy to implement. +
**Cons:** It is difficult to debug. +
**Alternative 2:** Creates a new findModule algorithm. +
**Pros:** It is easier to debug. +
**Cons:** We must ensure that the algorithm's logic is right and efficient.
// end::findmodule[]

// tag::sort[]
=== Sort mechanism

The sort mechanism is implemented using the `SortCommand`, which resides inside `Logic`. It supports sorting all the contacts in the address book in an alphabetical order.

When the user requests for ContactHub to be sorted, the list is sorted by implementing the `sortPersonListByName()` method from `Model`.
In the `sortPersonListByName()` method, the names of all persons in the internalList, which is an Observable List containing of Person, is compared using a comparator.

`SortCommand` inherits from Command and is implemented this way.
[source,java]
----
public class SortCommand extends Command {
    @Override
    public CommandResult execute() {
        // ... sort logic ...
    }
}
----

The `sortPersonListByName()` method is implemented this way.
[source,java]
----
public void sortPersonListByName() {
        Collections.sort(internalList, Comparator.comparing(firstPerson -> firstPerson.getName().fullName));
}
----

Suppose that the user has just launched ContactHub. The contact list will be arranged based on the add order at the beginning.

image::ListCommand.png[width="300"]

The user executes `SortCommand`, the list is now sorted alphabetically.

image::SortCommand.png[width="300"]

As the user continues to use the program, the contact list remains sorted in an alphabetical order.

[NOTE]
Upon exiting ContactHub, the contact list will not be sorted in the next subsequent launches.

==== Design Considerations

**Aspect:** Implementation of `SortCommand` +
**Alternative 1 (current choice):** `SortCommand` inherits from `Command`. +
**Pros:** After sorting, the contact list remains in an alphabetical order. +
**Cons:** The contact list cannot be saved in the sorted order. +
**Alternative 2:** Implement undo/redo for `SortCommand`. +
**Pros:** The user can switch between the sorted contact list and the original contact list.  +
**Cons:** `SortCommand` must be extended from `UndoableCommand` and must remember to call `super.execute()`, or lose the ability to undo/redo.

---

**Aspect:** How sort executes +
**Alternative 1 (current choice):** Uses the Java Collections.sort() method to sort the contact list in an alphabetical order. +
**Pros:** This method is easy to implement. +
**Cons:** This method is difficult to debug. +
**Alternative 2:** Creates a new sort algorithm. +
**Pros:** This method is easier to debug. +
**Cons:** We must ensure that the algorithm's logic is right and efficient.
// end::sort[]

// tag::addphoto[]
=== AddPhoto mechanism

The AddPhoto mechanism is facilitated by a `Photo` class, which is a property class of the
`Person` class. It allows the user to add a photo to each of the contacts.

The `Photo` class stores a **valid** web URL of an image that will be displayed in the `PersonListCard`.
Whenever a new contact is added into ContactHub, the new contact's `Photo` property will be set to a default image
of defaultPhoto. AddPhoto command can then be called to change from the defaultPhoto to a desired photo
of the user using the a **valid** URL. The photo of the contact can be changed back to default by calling
the AddPhoto command without any URL.

To add a photo to a contact, the `AddPhotoCommand` takes in the URL gave by the user and a
new `Photo` object is instantiated. `AddPhotoCommand` inherits from `UndoableCommand` and is therefore undoable using the `undo` function.
The `Photo` class would first check the validity of the URL,
if valid, the image will be downloaded and the photo of the contact would be updated accordingly, otherwise an IllegalValueException
will be thrown.

The `AddPhotoCommand` is implemented this way.
[source,java]
----

public class AddPhotoCommand extends UndoableCommand {
    @Override
        public CommandResult executeUndoableCommand() throws CommandException {
       // ... addPhoto logic ...

       }
}
----

Suppose the user has just added a contact into ContactHub. The photo of this contact will be defaultPhoto.

image::addphoto1.PNG[width="300"]

The user executes `AddPhotoCommand` and provides a **valid** web URL.

image::addphoto2.PNG[width="300"]

[NOTE]
After the execution, the list will return to the main contact list.

==== Design Considerations

**Aspects:** Implementation of `AddPhotoCommand`. +
**Alternative 1 (current choice):** Have `AddPhotoCommand` implement `UndoableCommand`. +
**Pros:** Retains the logic flow of how commands are executed. +
**Cons:** Increases coupling between the AddPhotoCommand class and the UndoableCommand interface.

---

**Aspects:** Choice of local or web URL to add photo to contact. +
**Alternative 1 (current choice):** Using web URL. +
**Pros:** Allows user to use web database to find the contact's photo. +
**Cons:** Might present a problem when there is no internet available for the user. +
**Alternative 2:** Using local URL. +
**Pros:** The contact may not have a photo stored in the web database. +
**Cons:** If there is no local photo of the contact, the user must download the contact's photo from the web
 onto he's computer first then use the local URL in the `AddPhotoCommand`.
// end::addphoto[]

// tag::keyboardshortcuts[]
=== Keyboard shortcuts

The keyboard shortcut function is facilitated mainly by the `commandBox` class which resides in the `UI` component.

It provides the user several functions when typing in the command box using different key bindings of the keyboard.

The `commandBox` class inherits the abstract class of `UIPart` which represents a distinct part of the `UI` like panels, windows and dialogs.

The `commandBox` class then calls the handleKeyPress() method whenever a key binding is pressed by the user. Using a switch statement for the
key bindings, the methods for each key bind will be carried out accordingly.

`CommandBox` inherits from UiPart and key binding functions are implemented this way.

[source,java]
----

public class CommandBox extends UiPart<Region> {
   private void handleKeyPress() {
       switch (keyEvent.getCode())
       // ...
       }
}
----

The `commandBox` class instantiates an object called `commandTextfield` of `TextField` class which is a JavaFX FXML, an XML-based language for building a user interface. The `TextField` class inherits the `TextInputControl` class which is the base class for text inputs.

[source,java]
----
The escape shortcut is implemented this way:
    case ESCAPE:
commandTextField.setText("");
break;
----

Suppose the user wants to delete everything in the command box. The user then executes the escape key on the user's keyboard.

image::keyboardsc1.PNG[width="300"]

image::keyboardsc2.PNG[width="300"]

In future, there would be more keyboard shortcuts like displaying all the prefixes of the AddCommand in the command box or keyboard shortcuts that would make a help guide appear.

==== Design Considerations

**Aspects:** Types of key bindings that relocates text cursor to the right. +
**Alternative 1 (current choice):** Use Control key as key binding. +
**Pros:** Easy key to execute when typing. +
**Cons:** May be executed unintentionally when executing windows commands. +
**Alternative 2:** Double click Right key as key binding. +
**Pros:** Easier to understand and execute for users. +
**Cons:** More difficult to implement.

---

**Aspects:** Data structure to support keyboard shortcuts. +
**Alternative 1 (current choice):** Implements in `commandBox` class using methods from `TextField` class. +
**Pros:** Easy to implement. +
**Cons:** May be hard for new developers to understand since there is no keyboard shortcuts class.
// end::keyboardshortcuts[]

=== Logging

We are using `java.util.logging` package for logging. The `LogsCenter` class is used to manage the logging levels and logging destinations.

* The logging level can be controlled using the `logLevel` setting in the configuration file (See link:#configuration[Configuration])
* The `Logger` for a class can be obtained using `LogsCenter.getLogger(Class)` which will log messages according to the specified logging level
* Currently log messages are output through: `Console` and to a `.log` file.

*Logging Levels*

* `SEVERE` : Critical problem detected which may possibly cause the termination of the application
* `WARNING` : Can continue, but with caution
* `INFO` : Information showing the noteworthy actions by the App
* `FINE` : Details that is not usually noteworthy but may be useful in debugging e.g. print the actual list instead of just its size

=== Configuration

Certain properties of the application can be controlled (e.g App name, logging level) through the configuration file (default: `config.json`).

// tag::nusmods[]

=== NUSMods Functionality

The NUSMods Functionality is facilitated mainly by the `MainWindow` class which is found
in the `ui` package.

// end::nusmods[]

// tag::googlemaps[]

=== Google Maps Functionality

The Google Maps Functionality is facilitated mainly by the `BrowserPanel` class which resides in the `UI` component.
 It provides the user the Google Maps location of a contact's address just by selecting them.

The `BrowserPanel` class inherits the abstract class of `UIPart` which represents a distinct part of the `UI` like panels, windows and dialogs.
The `BrowserPanel` class also instantiates an object of `WebView` class which is a JavaFX FXML, an XML-based language for building a user interface.
The `WebView` class provides access to the `WebEngine` which is the base class for loading Web pages, creating their document models, applying styles as necessary,
and runs JavaScript on pages. It provides access to the document of the current page, amd enables the Java application and JavaScript code of the page to communicate.

The HTML file "PersonBrowserPanel.html" has been created to load whenever a contact has been selected. It also hold the Javascript function
to allow pinpointing of the contact's address.

document.goToLocation = function goToLocation(searchString) {
                document.geocoder.geocode( {'address': searchString}, function(results, status) {
                    if (status == google.maps.GeocoderStatus.OK) {
                        //....load located address on Google Maps
                    } else {
                        alert("Geocode was not successful for the following reason: " + status);
                    }
                });
            }
Should the above function fail to load a location for the contact's address, an alert will be sent to indicate that there is an issue

// end::googlemaps[]

// tag::tasklist[]

=== Addition of TaskList

The Task List Functionality is facilitated mainly by the `TaskListPanel` class which resides in the `UI` component.
 It provides the user a list of their tasks to help remind them of what needs to be done.

The `TaskListPanel` class inherits the abstract class of `UIPart` which represents a distinct part of the `UI` like panels, windows and dialogs.
The `TaskListPanel` class also instantiates a list of `TaskCard` class which represents a UI component that displays information of a task.
The `TaskListCard.fxml` is an FXML file that interacts with the TaskCard class to produce the graphic displaying the details of the task.

// end::tasklist[]

// tag::addtask[]
=== AddTask mechanism

The AddTask mechanism is implemented using the `AddTaskCommand`, which resides inside `Logic`. It supports addition of tasks into ContactHub's task list.

The `Task` class stores a details of the task i.e Appointment, Date, and StartTime that will be displayed in the `TaskListPanel`.

When the user adds a new task to the `TaskList`, the a new task represented as a `TaskCard` will be created and shown.

To add a task in the task list, the `AddTaskCommand` takes in the Appointment, Date and StartTime as parameters for the task.

`AddTaskCommand` inherits from UndoableCommand and is therefore undoable using the `undo` function.

The `AddTaskCommand` is implemented this way.
[source,java]
----
public class AddTaskCommand extends UndoableCommand {
    @Override
    public CommandResult UndoableCommand() throws CommandException {
        // ... addTask logic ...
        }
}
----

Suppose that the user has just launched ContactHub.

image::BeforeAddTask.png[width="300"]

The user executes `AddTaskCommand` and provides the task's details.

image::AddTask.png[width="300"]

==== Design Considerations

**Aspects:** Implementation of `AddTaskCommand`. +
**Alternative 1 (current choice):** Have `AddTaskCommand` implement `UndoableCommand`. +
**Pros:** Retains the logic flow of how commands are executed. +
**Cons:** Increases coupling between the `AddTaskCommand` class and the `UndoableCommand` interface.

---

**Aspects:** How addTask executes +
**Alternative 1 (current choice):** A new task object is created using the the Appointment, Date and StartTime given as parameters. +
**Pros:** This method is easy to implement. +
**Cons:** This method is difficult to debug. +
**Alternative 2:** Creates a new addTask algorithm. +
**Pros:** This method is easier to debug. +
**Cons:** We must ensure that the algorithm's logic is right and efficient.
// end::addtask[]

// tag::edittask[]
=== EditTask mechanism

The EditTask mechanism is facilitated by the `Logic` class. It allows the user to edit a task in the task list.

The `Task` class stores the details of the task i.e appointment, date, and start time that will be displayed in the `TaskListPanel`.
Whenever EditTask command is inserted, the new details will replace the existing details of the selected task.

To edit a task in the task list, the `EditTaskCommand` takes in the index of the task and the details of the desired change.
`EditTaskCommand` inherits from `UndoableCommand` and is therefore undoable using the `undo` function.

The `EditTaskCommand` is implemented this way.
[source,java]
----

public class EditTaskCommand extends UndoableCommand {
    @Override
        public CommandResult executeUndoableCommand() throws CommandException {
       // ... editTask logic ...

       }
}
----

Suppose the user has just added a task into ContactHub.

image::AddTask.PNG[width="300"]

The user executes `EditTaskCommand` and provides the task's details.

image::EditTask.PNG[width="300"]

==== Design Considerations

**Aspects:** Implementation of `EditTaskCommand`. +
**Alternative 1 (current choice):** Have `EditTaskCommand` implement `UndoableCommand`. +
**Pros:** Retains the logic flow of how commands are executed. +
**Cons:** Increases coupling between the `EditTaskCommand` class and the `UndoableCommand` interface.

---

**Aspects:** How editTask executes +
**Alternative 1 (current choice):** A new task object is created and replaced the old task with the new task. +
**Pros:** This method is easy to implement. +
**Cons:** This method is difficult to debug. +
**Alternative 2:** Creates a new editTask algorithm. +
**Pros:** This method is easier to debug. +
**Cons:** We must ensure that the algorithm's logic is right and efficient.
// end::edittask[]

// tag::deletetask[]
=== DeleteTask mechanism

The DeleteTask mechanism is facilitated by the `Logic` class. It allows the user to delete a task in the task list.

Whenever DeleteTask command is inserted, the selected task will be removed from the task list.

To delete a task in the task list, the `DeleteTaskCommand` takes in the index of the task and the task is deleted.
`DeleteTaskCommand` inherits from `UndoableCommand` and is therefore undoable using the `undo` function.

The `DeleteTaskCommand` is implemented this way.
[source,java]
----

public class DeleteTaskCommand extends UndoableCommand {
    @Override
        public CommandResult executeUndoableCommand() throws CommandException {
       // ... deleteTask logic ...

       }
}
----

Suppose the user has just added a task into ContactHub.

image::AddTask.PNG[width="300"]

The user executes `DeleteTaskCommand` and provides the task's details.

image::DeleteTask.PNG[width="300"]

==== Design Considerations

**Aspects:** Implementation of `DeleteTaskCommand`. +
**Alternative 1 (current choice):** Have `DeleteTaskCommand` implement `UndoableCommand`. +
**Pros:** Retains the logic flow of how commands are executed. +
**Cons:** Increases coupling between the `DeleteTaskCommand` class and the `UndoableCommand` interface.

---

**Aspects:** How deleteTask executes +
**Alternative 1 (current choice):** The user gives the index of the task to be deleted and the task is deleted. +
**Pros:** This method is easy to implement. +
**Cons:** This method is difficult to debug. +
**Alternative 2:** Creates a new deleteTask algorithm. +
**Pros:** This method is easier to debug. +
**Cons:** We must ensure that the algorithm's logic is right and efficient.
// end::deletetask[]

== Documentation

We use asciidoc for writing documentation.

[NOTE]
We chose asciidoc over Markdown because asciidoc, although a bit more complex than Markdown, provides more flexibility in formatting.

=== Editing Documentation

See <<UsingGradle#rendering-asciidoc-files, UsingGradle.adoc>> to learn how to render `.adoc` files locally to preview the end result of your edits.
Alternatively, you can download the AsciiDoc plugin for IntelliJ, which allows you to preview the changes you have made to your `.adoc` files in real-time.

=== Publishing Documentation

See <<UsingTravis#deploying-github-pages, UsingTravis.adoc>> to learn how to deploy GitHub Pages using Travis.

=== Converting Documentation to PDF format

We use https://www.google.com/chrome/browser/desktop/[Google Chrome] for converting documentation to PDF format, as Chrome's PDF engine preserves hyperlinks used in webpages.

Here are the steps to convert the project documentation files to PDF format.

.  Follow the instructions in <<UsingGradle#rendering-asciidoc-files, UsingGradle.adoc>> to convert the AsciiDoc files in the `docs/` directory to HTML format.
.  Go to your generated HTML files in the `build/docs` folder, right click on them and select `Open with` -> `Google Chrome`.
.  Within Chrome, click on the `Print` option in Chrome's menu.
.  Set the destination to `Save as PDF`, then click `Save` to save a copy of the file in PDF format. For best results, use the settings indicated in the screenshot below.

image::chrome_save_as_pdf.png[width="300"]
_Figure 5.6.1 : Saving documentation as PDF files in Chrome_

== Testing

=== Running Tests

There are three ways to run tests.

[TIP]
The most reliable way to run tests is the 3rd one. The first two methods might fail some GUI tests due to platform/resolution-specific idiosyncrasies.

*Method 1: Using IntelliJ JUnit test runner*

* To run all tests, right-click on the `src/test/java` folder and choose `Run 'All Tests'`
* To run a subset of tests, you can right-click on a test package, test class, or a test and choose `Run 'ABC'`

*Method 2: Using Gradle*

* Open a console and run the command `gradlew clean allTests` (Mac/Linux: `./gradlew clean allTests`)

[NOTE]
See <<UsingGradle#, UsingGradle.adoc>> for more info on how to run tests using Gradle.

*Method 3: Using Gradle (headless)*

Thanks to the https://github.com/TestFX/TestFX[TestFX] library we use, our GUI tests can be run in the _headless_ mode. In the headless mode, GUI tests do not show up on the screen. That means the developer can do other things on the Computer while the tests are running.

To run tests in headless mode, open a console and run the command `gradlew clean headless allTests` (Mac/Linux: `./gradlew clean headless allTests`)

=== Types of tests

We have two types of tests:

.  *GUI Tests* - These are tests involving the GUI. They include,
.. _System Tests_ that test the entire App by simulating user actions on the GUI. These are in the `systemtests` package.
.. _Unit tests_ that test the individual components. These are in `seedu.address.ui` package.
.  *Non-GUI Tests* - These are tests not involving the GUI. They include,
..  _Unit tests_ targeting the lowest level methods/classes. +
e.g. `seedu.address.commons.StringUtilTest`
..  _Integration tests_ that are checking the integration of multiple code units (those code units are assumed to be working). +
e.g. `seedu.address.storage.StorageManagerTest`
..  Hybrids of unit and integration tests. These test are checking multiple code units as well as how the are connected together. +
e.g. `seedu.address.logic.LogicManagerTest`


=== Troubleshooting Testing
**Problem: `HelpWindowTest` fails with a `NullPointerException`.**

* Reason: One of its dependencies, `UserGuide.html` in `src/main/resources/docs` is missing.
* Solution: Execute Gradle task `processResources`.

== Dev Ops

=== Build Automation

See <<UsingGradle#, UsingGradle.adoc>> to learn how to use Gradle for build automation.

=== Continuous Integration

We use https://travis-ci.org/[Travis CI] and https://www.appveyor.com/[AppVeyor] to perform _Continuous Integration_ on our projects. See <<UsingTravis#, UsingTravis.adoc>> and <<UsingAppVeyor#, UsingAppVeyor.adoc>> for more details.

=== Making a Release

Here are the steps to create a new release.

.  Update the version number in link:{repoURL}/src/main/java/seedu/address/MainApp.java[`MainApp.java`].
.  Generate a JAR file <<UsingGradle#creating-the-jar-file, using Gradle>>.
.  Mod the repo with the version number. e.g. `v0.1`
.  https://help.github.com/articles/creating-releases/[Create a new release using GitHub] and upload the JAR file you created.

=== Managing Dependencies

A project often depends on third-party libraries. For example, Address Book depends on the http://wiki.fasterxml.com/JacksonHome[Jackson library] for XML parsing. Managing these _dependencies_ can be automated using Gradle. For example, Gradle can download the dependencies automatically, which is better than these alternatives. +
a. Include those libraries in the repo (this bloats the repo size) +
b. Require developers to download those libraries manually (this creates extra work for developers)

[appendix]
== User Stories

Priorities: High (must have) - `* * \*`, Medium (nice to have) - `* \*`, Low (unlikely to have) - `*`

[width="59%",cols="22%,<23%,<25%,<30%",options="header",]
|=======================================================================
|Priority |As a ... |I want to ... |So that I can...
|`* * *` |new user |see usage instructions |refer to instructions when I forget how to use the App

|`* * *` |user |add a new person |

|`* * *` |user |delete a person |remove entries that I no longer need

|`* * *` |user |find a person by name |locate details of persons without having to go through the entire list

|`* * *` |user |search for another user's contact number by the person's name |

|`* * *` |user |be able to create contacts without filling out every detail |

|`* * *` |user |add a home or office number |prevent the need of creating another person of same name

|`* * *` |user |add multiple phone numbers or addresses to a person|

|`* * *` |user |add multiple mods to a person |my contacts are more recognizable

|`* * *` |user |have different coloured mods |differentiate my contacts easier

|`* * *` |user |edit the contact once added |change my errors

|`* *` |user |be able to interact with specific details for each person |

|`* *` |user |send email to a person |communicate with that contact

|`* *` |user |sort by first or last name |

|`* *` |new user |have introduction page |see the basic functions

|`* *` |user |have a better web function than Google search when i select a person|

|`* *` |user |click on specific details for each person |see more feature of each detail

|`* *` |user |right-click on the person |perform more functions for each person

|`* *` |user |know which persons are mutual friends |

|`* *` |calculated user |have statistics of selecting each person |know how often i select a person overtime

|`* *` |user |favourite a person |have ease of access to that person

|`* *` |user |import contacts from iCloud or Google Contacts |

|`* *` |user |have suggestions for persons |have ease of access base on the frequency of accessing the person

|`* *` |user |have the list to be updated immediately when i type the letters one by one |

|`* *` |user |have keyboard shortcuts |

|`* *` |user |see the top 3 more searched persons at the top |have ease of access

|`* *` |user |add birthdays to each person |

|`* *` |user |search by mods |filter by mods only

|`* *` |user |add notes to each person |remind myself of things related to the person

|`* *` |new user |choose font size |

|`* *` |user |add friends |able to contact or communicate with them better

|`* *` |user |have the command message box to be better suited for history |

|`* *` |user |have a display picture for each person |recognise each persone easier

|`* *` |user |hide link:#private-contact-detail[private contact details] by default |minimize chance of someone else seeing them by accident

|`*` |user |search the address of a person on Google Maps |

|`*` |user |click on the person |see the details of the person more specifically

|`*` |user |see the command format as soon as i type the command |

|`*` |new user |not have example contacts |

|`*` |user with many persons in the address book |sort persons by name |locate a person easily
|=======================================================================

{More to be added}

[appendix]
== Use Cases

(For all use cases below, the *System* is `ContactHub` and the *Actor* is the `user`, unless specified otherwise)


[discrete]
=== Use case: Help

*MSS*

1.  User requests for help.
2.  ContactHub shows the UserGuide to the user.
+
Use case ends.

[discrete]
=== Use case: Add person

*MSS*

1.  User adds a person to ContactHub
2.  ContactHub adds the person to the list
3.  ContactHub displays a successful added message with the person's details
+
Use case ends.

*Extensions*

[none]
* 1a. The format for add person is incorrect.
[none]
** 1a1. ContactHub shows an error message
** 1a2. User adds a person to the ContactHub
+
Steps 1a1-1a2 are repeated until the details are in the correct format.
+
Use case resumes at step 2.

[discrete]
=== Use case: List

*MSS*

1. User requests to list persons
2. ContactHub shows a list of persons
+
Use case ends.

*Extensions*

[none]
* 2a. The list is empty.
+
Use case ends.

[discrete]
=== Use case: Sort

*MSS*

1. User requests to sort persons
2. ContactHub shows a list of persons sorted alphabetically.
+
Use case ends.

*Extensions*

[none]
* 2a. The list is empty.
+
Use case ends.

[discrete]
=== Use case: List all Modules

*MSS*

1. User requests to list all modules in ContactHub.
2. ContactHub shows a list of modules in ContactHub.
+
Use case ends.

*Extensions*

[none]
* 2a. The list is empty.
+
Use case ends.

[discrete]
=== Use case: Edit person

*MSS*

1. User requests to list persons
2. ContactHub shows a list of persons
3. User requests to edit a specific person in the list
4. User keys in the new details of the person
5. ContactHub stores the new details of the person
+
Use case ends.

*Extensions*

[none]
* 2a. The list is empty.
+
Use case ends.

* 3a. The given index is invalid
+
[none]
** 3a1. ContactHub shows an error message.
+
Use case resumes at step 2.


[discrete]
=== Use case: Find person(s)

*MSS*

1.  User requests to find a person(s)
2.  ContactHub displays a list of person(s) with the same name
+
Use case ends.

*Extensions*

[none]
* 2a. ContactHub does not contain the person.
+
Use case ends.

[discrete]
=== Use case: Find module(s)

*MSS*

1.  User requests to find a person(s) with the searched module.
2.  ContactHub displays a list of person(s) with the mod name keyed in.
+
Use case ends.

*Extensions*

[none]
* 2a. ContactHub does not contain anyone with the module.
+
Use case ends.

[discrete]
=== Use case: Delete person

*MSS*

1.  User requests to list persons
2.  ContactHub shows a list of persons
3.  User requests to delete a specific person in the list
4.  ContactHub deletes the person
+
Use case ends.

*Extensions*

[none]
* 2a. The list is empty.
+
Use case ends.

* 3a. The given index is invalid.
+
[none]
** 3a1. ContactHub shows an error message.
+
Use case resumes at step 2.

[discrete]
=== Use case: Add photo
*MSS*

1.  User requests to list persons
2.  ContactHub shows a list of persons
3.  User requests to add a photo to a person in the list
4.  ContactHub adds a photo to that person
+
Use case ends.

*Extensions*

[none]
* 2a. The list is empty.
+
Use case ends.

* 3a. The given index is invalid.
+
[none]
** 3a1. ContactHub shows an error message.
+
Use case resumes at step 2.
* 3b. The given web URL is invalid.
+
[none]
** 3b1. ContactHub shows an error message.
+
Use case resumes at step 2.

[discrete]

[discrete]
=== Use case: Select person

*MSS*

1.  User requests to list persons
2.  ContactHub shows a list of persons
3.  User requests to select a person in the list
4.  ContactHub opens a Google Search of that person
+
Use case ends.

*Extensions*

[none]
* 2a. The list is empty.
+
Use case ends.

* 3a. The given index is invalid.
+
[none]
** 3a1. ContactHub shows an error message.
+
Use case resumes at step 2.

[discrete]
=== Use case: Add task

*MSS*

1.  User adds a task to ContactHub
2.  ContactHub adds the task to the task list
3.  ContactHub displays a successful added message with the task's details
+
Use case ends.

*Extensions*

[none]
* 1a. The format for add task is incorrect.
[none]
** 1a1. ContactHub shows an error message
** 1a2. User adds a task to the ContactHub
+
Steps 1a1-1a2 are repeated until the details are in the correct format.
+
Use case ends.

[discrete]
=== Use case: Edit task

*MSS*

1. User requests to edit a specific task in the task list.
2. User keys in the new details of the task.
3. ContactHub stores the new details of the task.
+
Use case ends.

*Extensions*

* 1a. The given index is invalid
+
[none]
** 1a1. ContactHub shows an error message.
+
Use case ends.

[none]
* 1b. The task list is empty.
+
Use case ends.

[discrete]
=== Use case: Delete task

*MSS*

1.  User requests to delete a specific task in the list.
2.  ContactHub deletes the task.
+
Use case ends.

*Extensions*


* 1a. The given index is invalid.
+
[none]
** 1a1. ContactHub shows an error message.
+
Use case ends.

[none]
* 1b. The list is empty.
+
Use case ends.

[discrete]
=== Use case: History

*MSS*

1. User requests for command history
2. ContactHub displays a list of command history
+
Use case ends.

*Extensions*

[none]
* 2a. ContactHub does not have any command history.
+
Use case ends.


[discrete]
=== Use case: Undo

*MSS*

1. User requests for undo
2. ContactHub undo the last undoable command
+
Use case ends.

*Extensions*

[none]
* 2a. ContactHub has no more undoable command
+
Use case ends.


[discrete]
=== Use case: Redo

*MSS*

1. User requests for redo
2. ContactHub redo the last undoable command
+
Use case ends.

*Extensions*

[none]
* 2a. ContactHub has no more undoable command
+
Use case ends.


[discrete]
=== Use case: Clear

*MSS*

1. User requests to clear ContactHub
2. ContactHub clears all the data
+
Use case ends.


[discrete]
=== Use case: Exit

*MSS*

1. User requests to exit ContactHub
2. ContactHub closes the program
+
Use case ends.

{more to be added}

[appendix]
== Non Functional Requirements

.  Should work on any link:#mainstream-os[mainstream OS] as long as it has Java `1.8.0_60` or higher installed.
.  Should be able to hold up to 1000 persons without a noticeable sluggishness in performance for typical usage.
.  A user with above average typing speed for regular English text (i.e. not code, not system admin commands) should be able to accomplish most of the tasks faster using commands than using the mouse.
.  User has access to alphanumeric inputs to use command line interface.
.  User has access to Internet to use Google search engine services.
.  User is able to access instructions on how to use the app.
.  User has access to a monitor in order to view the app.
.  User has access to a working power source in order to power up the device running the application.
.  Response time for any command should be within 5 seconds.
.  The source code should be open source.
.  Mean time to recovery must be 10 seconds maximum.
.  Must be user friendly even for non IT-savvy, conforms to user standards.
.  Conforms to coding standards.
.  All data must be protectively marked and stored
.  User must have basic English literacy.

{More to be added}

[appendix]
== Glossary

[[mainstream-os]]
Mainstream OS

....
Windows, Linux, Unix, OS-X
....

[[private-contact-detail]]
Private contact detail

....
A contact detail that is not meant to be shared with others
....

[[main-success-scenario]]
Main Success Scenario (MSS)

....
The most straightforward interaction for a given use case, which assumes that nothing goes wrong.
....

[[extensions]]
Extensions

....
Extensions are "add-on"s to the MSS that describe exceptional/alternative flow of events.
....

